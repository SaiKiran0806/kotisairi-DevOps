first session(UI):

Creating Public Repository--> (Individual/collaborators/anyone online can access/view/add/modify in the repository)
Creating Private Repository--> (Only the individual/specified people can access)

==>Creating a file with some content within the default branch(main) in the repository.
==>Commit changes --> helpful for saving the data created. Title and Description should be in organised format, 
   so that it will be helpful for others to view clearly and also who have made the commit changes.
==>Uploading a existing file from local, choose the file, commit changes.
==>We can see what commit changes made by every individual in the repository on specific repository dashboard.
==>both public & private interfaces are same.

second session(UI):
Creating nested branches:
==>Main branch has a single data file.
==>with main branch as the source created a new branch(sub1), automatically auto-merge done with the files in the main branch copied to sub1 branch.
==>now added some contents/files to the sub1 branch.
==>Files in main branch-->1 & files in sub1 branch --> >1
==>Creating new branch(sub2) with "main as source" & another new branch(sub3) with "sub1 as source". 
==>Now the default branch for sub2 is "main" so files in sub2 --> only 1
==>here default branch for sub3 is "sub1" so files in sub3 --> >1

Pull Request: Useful for merge the content/files in one existing branch to the other existing branch(exa: main branch)
==>Files in sub1 --> >1 & files in main--> only 1
==>Go to repo interface with option "Pull requests" -->create new pull request
==>select "base:main (destination branch to be copied/merged)"  &  select "compare: sub1 (source branch to be copied) ---> select pull request
==>Wait until u get "NO CONFLICTS RAISED WITH BASE BRANCH" --> select pull request ---> check the number of files in the main branch (modified to >1 files in the main branch also)
==>Now that you have all files in the default branch, you can delete the contents or the SUB1 branch
Restore Branch: 
==>If somehow you needed the deleted branch but later required now, then you can restore the deleted branch.

third session(CLI):
==>Accessing Git through terminal/Git bash/Mobaxterm
==>Create a private repo so that it will be easy for understanding the SSH/GPG keys.
==>After creating repository copy the SSH URL and move on dedicated terminal --># git clone "URL"
==>If there are already SSH keys, get connected orelse you encounter error--> "Permission denied (publickey)" 

New SSH keys generating:
==>In terminal --> # ssh-keygen --> check path --> overwritten (if already existed) --> yes....
==> # cd "paste the path"  --->if path has spaces between use "path/.ssh" ---> pwd (for re-checking) --> ls
==>check the files with ".pub" ---> cat paste ".pub" -->copy the keys in the UI part (SSH & GPG keys ---> paste the key generated(create Title,authentication,key-->add key)-->password for confirmation)
==>now that you have created ssh-keys--->again connect

Creating file and pushing from CLI to remote(Git)
==> # git clone "SSH-URL" (check the path-->Desktop)
==>here the repository in UI is the directory in the CLI (repository name can been seen as directory)
==>cd repository name -->automatically branch creates --->now push the files from CLI to remote repository(UI) ---> to do this there are stages(GIT stages) in between
==>Git stages--> 1.Working directory-redcolor (--->push to--->) 2.Staging area-greencolor(-->push to--->) 3.local repository-nocolor(-->push to--->) 4.remote repositoty(GIT)
==> # git status--> to check status of files
==> # git add filename--> red color--?to move from working directory to staging area 
==> # git commit -m "message you want to give" ---> green color --> to move from staging area to local repository
    Encountered error ---> Author identity unknown ---> managed to clear the error (name & email)
==> finally you should get--> "nothing to commit, working tree clean"
==> # git push ---> to move from local repository to remote repository (check in remote repo)-->file accessed in UI which is created in CLI

Deleting the repository in CLI: (same like the deletion of directory)
==> # rm -rf directory_name --->(-rf means removing non-empty forcefully)

HTTP connection:
==>Copy URl --> # git clone "URL -->if no tokens then a pop up appears 1.Browser(username,pswd) 2.Token
==>For generating token ---> setting-->Developer tokens-->Personal access tokens --> Tokens (classic) --> Generate new token(name, date....) --> Copy the Token safely as they are one-time view
==>In the pop-up give the token --> you are connected to CLI

Creating Branch:
==> # git branch branchname      --> to create branch
==> # git branch                 --> to check in which branch we are
==> # git checkout branchname    --> to switch to other brnaches
==> auto-merge is done automatically while branch is created i.e all the files in source branch will be copied to this destination branch (newly created)
==> # git checkout -b branchname  -> to create a new branch and switch to it automatically
Delete Branch:
==> # git branch --delete branchname  (or) # git branch -d brname   --> only deletes if we are outside the branch or else doesn't delete
Restore Branch:
==> At the time of deletion of branch a 'code' is generated to branch so copy that.
==> # git branch 'deleted_br_name' 'code'  --> to restore the branch

Push branches to remote repo:
==> Branches we created only shows in CLI but not in GIT so for that
==> # git push origin branchname  --> origin is keyword
==> # git remote                  --> to check which keywords are there
==> # git remote add newkeyword URL_link  --> to create new keywords

Delete Branch in UI from CLI:
==> git push origin --delete brname   --> to delete branch in UI from CLI (but this only deletes in UI but not in CLI)

Copy files between two existing branches(within CLI):
==> Create some files and commit in the brance
==> # git add .   ---> to add all the files at once from staging area to local repo
==> switch to the breanch to which merge should be done(for exa: main)
==> # git merge source_br  --> files in source branch merges to destination branch(main) 

to list out the commits(In CLI):
==> # git log                  --> lists out the commits (q for quit)
==> # git log --oneline        --> lists out commits line by line

pick up specific commit and merge to existing branch(in CLI)
==> copy the commit id(atleast 8 letters)
==> # git cherry-pick "paste commit id"    --> to merge specific commit in existing branch to other existing branch

Commit importance & how to secure if it is still not to commit stage(in CLI):
==> if we create a file in CLI it shows in all branches in working repo, staging area also until unless it is commit in specific branch
==> One who commit is the one who is creator of file so commit is necessary.
==> # git stash save filename     ---> to secure file if not commit (i.e in working or staging area)

list out secure files if not commit(in CLI):
==> # git stash list            ---> to view secured file and also lists us in which branch it is

to bring back secured file to working or staging area(in CLI):
==> # git stash apply filename (or) # git stash apply stash_id       ---> for temporarily show the file 
==> # git stash pop stash_id                                         ---> for permanently show the file again in working or staging area

Restore modified data to original in file(in CLI):
==> # git checkout -- filename          --> restore to original data if it is in -->working repo
==> # git reset HEAD filename           --> restore back from staging area to working area  ---> from working area to original ( # git checkout -- filename)
==> # git reset head~ "filename"        --> restore back from local repo(commit) to working area because staging area is temporary ---> from working area to original ( # git checkout -- filename)
==> # git reset head~ 
==> # git checkout -- filename
==> # git push -f                        --> all above 3 steps for forcefully restoring back the modified data to original data in UI

Modified data(UI) to be applied in CLI:
==> # git pull                             --> if modified data applied to all branches
==> # git fetch                            --> if modified data only to specific branch

fourth session:
Modifiy commits(in CLI):
==> # git commit --amend -m "commit message"       --> change commit for recent log
==> # git rebase -i HEAD~"no.of commits"           --> change specific commit (will go insert mode, select one command, save, commit the message, save)                    

errors not raised but check the errors--->
==> Conflicts not raised while doing work but check the various conflicts.
